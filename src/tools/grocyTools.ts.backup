/**
 * Created: 08/11/25
 * By: Daniel Potter
 *
 * Grocy REST API integration for MCP server.
 * Provides kitchen inventory management, shopping lists, recipes, and more.
 *
 * Requires environment variables:
 * - GROCY_BASE_URL: Base URL of Grocy instance (e.g., https://grocy.example.com)
 * - GROCY_API_KEY: API key from Grocy user settings (Manage API keys)
 *
 * References:
 * - Grocy API Docs: https://github.com/grocy/grocy/blob/master/grocy.openapi.json
 * - Grocy GitHub: https://github.com/grocy/grocy
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { genericLimiter } from "../utils/cache.js";

/**
 * Grocy product with stock information
 */
interface GrocyProduct {
	id: number;
	name: string;
	description?: string;
	location_id?: number;
	qu_id_stock: number;
	qu_id_purchase: number;
	min_stock_amount: number;
	default_best_before_days: number;
	product_group_id?: number;
	picture_file_name?: string;
	barcode?: string;
}

/**
 * Current stock response for a product
 */
interface GrocyStockResponse {
	product_id: number;
	amount: string;
	amount_aggregated: string;
	amount_opened: string;
	amount_opened_aggregated: string;
	best_before_date: string;
	is_aggregated_amount?: boolean;
	product?: GrocyProduct;
}

/**
 * Stock entry with location and dates (unused but kept for future use)
 */
// @ts-ignore - Unused interface kept for API reference
interface _GrocyStockEntry {
	id: string;
	product_id: number;
	amount: string;
	best_before_date: string;
	purchased_date: string;
	stock_id: string;
	price?: number;
	open: number;
	opened_date?: string;
	location_id: number;
	shopping_location_id?: number;
	note?: string;
}

/**
 * Product details with extended information
 */
interface GrocyProductDetails {
	product: GrocyProduct;
	last_purchased?: string;
	last_used?: string;
	stock_amount: number;
	stock_amount_opened: number;
	next_best_before_date?: string;
	last_price?: number;
	avg_price?: number;
	location?: { id: number; name: string };
}

/**
 * Shopping list item (unused but kept for future use)
 */
// @ts-ignore - Unused interface kept for API reference
interface _GrocyShoppingListItem {
	id: number;
	product_id?: number;
	note?: string;
	amount: number;
	shopping_list_id: number;
	done: number;
	qu_id?: number;
}

/**
 * Volatile stock (expiring, overdue, missing products)
 */
interface GrocyVolatileStock {
	due_products: GrocyStockResponse[];
	overdue_products: GrocyStockResponse[];
	expired_products: GrocyStockResponse[];
	missing_products: Array<{
		id: number;
		name: string;
		amount_missing: number;
		is_partly_in_stock: boolean;
	}>;
}

/**
 * Recipe fulfillment information
 */
interface GrocyRecipeFulfillment {
	need_fulfilled: boolean;
	need_fulfilled_with_shopping_list: boolean;
	missing_products: Array<{
		id: number;
		amount_missing: number;
		amount_missing_for_recipe: number;
	}>;
}

/**
 * Task information (unused but kept for future use)
 */
// @ts-ignore - Unused interface kept for API reference
interface _GrocyTask {
	id: number;
	name: string;
	description?: string;
	due_date?: string;
	done: number;
	done_timestamp?: string;
	category_id?: number;
	assigned_to_user_id?: number;
}

/**
 * Stock log entry (transaction)
 */
interface GrocyStockLogEntry {
	id: number;
	product_id: number;
	amount: string;
	best_before_date: string;
	purchased_date: string;
	transaction_type: string;
	price?: number;
	location_id?: number;
	note?: string;
}

/**
 * Make authenticated request to Grocy API
 */
async function grocyRequest(
	endpoint: string,
	method: "GET" | "POST" | "PUT" | "DELETE" = "GET",
	body?: unknown
): Promise<unknown> {
	const baseUrl = process.env.GROCY_BASE_URL;
	const apiKey = process.env.GROCY_API_KEY;

	if (!baseUrl) {
		throw new Error(
			"GROCY_BASE_URL environment variable is not set. Please add your Grocy instance URL."
		);
	}

	if (!apiKey) {
		throw new Error(
			"GROCY_API_KEY environment variable is not set. " +
				"Please create an API key in Grocy user settings (Manage API keys)."
		);
	}

	// Ensure URL doesn't end with slash for consistent endpoint construction
	const normalizedUrl = baseUrl.replace(/\/$/, "");
	const url = `${normalizedUrl}/api/${endpoint}`;

	const headers: Record<string, string> = {
		"GROCY-API-KEY": apiKey,
		"Content-Type": "application/json",
		Accept: "application/json",
	};

	const options: RequestInit = {
		method,
		headers,
	};

	if (body && (method === "POST" || method === "PUT")) {
		options.body = JSON.stringify(body);
	}

	const response = await fetch(url, options);

	if (!response.ok) {
		const errorText = await response.text();
		let errorMessage = `Grocy API error: ${response.status} ${response.statusText}`;

		try {
			const errorJson = JSON.parse(errorText) as {
				error_message?: string;
				error?: string;
			};
			if (errorJson.error_message) {
				errorMessage = errorJson.error_message;
			} else if (errorJson.error) {
				errorMessage = errorJson.error;
			}
		} catch {
			// Error response wasn't JSON, use text
			if (errorText) {
				errorMessage += ` - ${errorText}`;
			}
		}

		throw new Error(errorMessage);
	}

	// Some endpoints return 204 No Content
	if (response.status === 204 || method === "DELETE") {
		return { success: true };
	}

	return await response.json();
}

/**
 * Register Grocy tools with the MCP server
 */
export function registerGrocyTools(server: McpServer) {
	// STOCK - GET CURRENT STOCK
	server.registerTool(
		"grocy_stock_get_current",
		{
			title: "Get Current Stock Overview",
			description:
				"Returns all products currently in stock with amounts, locations, and best before dates. " +
				"This is your main stock overview showing what you have on hand.",
			inputSchema: {},
			outputSchema: {
				stock: z.array(
					z.object({
						product_id: z.number(),
						product_name: z.string().optional(),
						amount: z.string(),
						amount_opened: z.string(),
						best_before_date: z.string(),
						location_id: z.number().optional(),
					})
				),
			},
		},
		async () => {
			try {
				// Apply rate limiting
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds before making another request.`,
							},
						],
						isError: true,
					};
				}

				const data = (await grocyRequest("stock")) as GrocyStockResponse[];

				// Format results
				const formattedStock = data.map((item) => ({
					product_id: item.product_id,
					product_name: item.product?.name,
					amount: item.amount_aggregated || item.amount,
					amount_opened: item.amount_opened_aggregated || item.amount_opened,
					best_before_date: item.best_before_date,
					location_id: item.product?.location_id,
				}));

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									total_products: formattedStock.length,
									stock: formattedStock,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error fetching stock: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// STOCK - GET PRODUCT DETAILS
	server.registerTool(
		"grocy_stock_get_product",
		{
			title: "Get Product Details",
			description:
				"Returns detailed information about a specific product including current stock, " +
				"locations, prices, and usage history.",
			inputSchema: {
				product_id: z
					.number()
					.positive()
					.describe("The ID of the product to retrieve"),
			},
			outputSchema: {
				product: z.object({
					id: z.number(),
					name: z.string(),
					stock_amount: z.number(),
					location: z.string().optional(),
					last_purchased: z.string().optional(),
					last_used: z.string().optional(),
					avg_price: z.number().optional(),
				}),
			},
		},
		async ({ product_id }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const data = (await grocyRequest(
					`stock/products/${product_id}`
				)) as GrocyProductDetails;

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									id: data.product.id,
									name: data.product.name,
									description: data.product.description,
									stock_amount: data.stock_amount,
									stock_amount_opened: data.stock_amount_opened,
									location: data.location?.name,
									last_purchased: data.last_purchased,
									last_used: data.last_used,
									next_best_before_date: data.next_best_before_date,
									last_price: data.last_price,
									avg_price: data.avg_price,
									min_stock_amount: data.product.min_stock_amount,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error fetching product: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// STOCK - ADD PRODUCT (PURCHASE)
	server.registerTool(
		"grocy_stock_add_product",
		{
			title: "Add Product to Stock",
			description:
				"Adds a product to stock (purchase). Records the purchase with amount, price, " +
				"best before date, and location.",
			inputSchema: {
				product_id: z.number().positive().describe("The product ID to add"),
				amount: z
					.number()
					.positive()
					.describe("Amount to add in stock quantity units"),
				best_before_date: z
					.string()
					.optional()
					.describe(
						"Best before date (YYYY-MM-DD), defaults to today if omitted"
					),
				price: z.number().optional().describe("Price per stock quantity unit"),
				location_id: z
					.number()
					.optional()
					.describe("Location ID, uses product default if omitted"),
				shopping_location_id: z
					.number()
					.optional()
					.describe("Store/shop where purchased"),
				note: z
					.string()
					.optional()
					.describe("Optional note for this stock entry"),
			},
			outputSchema: {
				transaction: z.object({
					product_id: z.number(),
					amount: z.string(),
					transaction_type: z.string(),
					success: z.boolean(),
				}),
			},
		},
		async ({
			product_id,
			amount,
			best_before_date,
			price,
			location_id,
			shopping_location_id,
			note,
		}) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const body: Record<string, unknown> = {
					amount,
					transaction_type: "purchase",
				};

				if (best_before_date) body.best_before_date = best_before_date;
				if (price !== undefined) body.price = price;
				if (location_id) body.location_id = location_id;
				if (shopping_location_id)
					body.shopping_location_id = shopping_location_id;
				if (note) body.note = note;

				const data = (await grocyRequest(
					`stock/products/${product_id}/add`,
					"POST",
					body
				)) as GrocyStockLogEntry[];

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Added ${amount} unit(s) of product ${product_id} to stock`,
									transaction: data[0],
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error adding product to stock: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// STOCK - CONSUME PRODUCT
	server.registerTool(
		"grocy_stock_consume_product",
		{
			title: "Consume Product from Stock",
			description:
				"Removes a product from stock (consume/use). Uses FIFO (First In First Out) by default. " +
				"Can mark as spoiled if the product went bad.",
			inputSchema: {
				product_id: z.number().positive().describe("The product ID to consume"),
				amount: z
					.number()
					.positive()
					.describe("Amount to consume in stock quantity units"),
				spoiled: z
					.boolean()
					.optional()
					.default(false)
					.describe("True if the product was spoiled/wasted"),
				location_id: z
					.number()
					.optional()
					.describe("Consume from specific location only"),
				recipe_id: z
					.number()
					.optional()
					.describe("Recipe ID if consumed for a recipe"),
			},
			outputSchema: {
				transaction: z.object({
					product_id: z.number(),
					amount: z.string(),
					transaction_type: z.string(),
					spoiled: z.boolean(),
					success: z.boolean(),
				}),
			},
		},
		async ({ product_id, amount, spoiled = false, location_id, recipe_id }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const body: Record<string, unknown> = {
					amount,
					transaction_type: "consume",
					spoiled,
				};

				if (location_id) body.location_id = location_id;
				if (recipe_id) body.recipe_id = recipe_id;

				const data = (await grocyRequest(
					`stock/products/${product_id}/consume`,
					"POST",
					body
				)) as GrocyStockLogEntry[];

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Consumed ${amount} unit(s) of product ${product_id}${
										spoiled ? " (spoiled)" : ""
									}`,
									transaction: data[0],
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error consuming product: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// STOCK - GET VOLATILE (EXPIRING/MISSING)
	server.registerTool(
		"grocy_stock_get_volatile",
		{
			title: "Get Expiring/Missing Products",
			description:
				"Returns products that are expiring soon, overdue, already expired, or below minimum stock. " +
				"Essential for managing food waste and restocking.",
			inputSchema: {
				due_soon_days: z
					.number()
					.optional()
					.default(5)
					.describe("Number of days to consider as 'due soon' (default: 5)"),
			},
			outputSchema: {
				volatile: z.object({
					due_products_count: z.number(),
					overdue_products_count: z.number(),
					expired_products_count: z.number(),
					missing_products_count: z.number(),
				}),
			},
		},
		async ({ due_soon_days = 5 }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const data = (await grocyRequest(
					`stock/volatile?due_soon_days=${due_soon_days}`
				)) as GrocyVolatileStock;

				// Format each category
				const formatProducts = (products: GrocyStockResponse[]) =>
					products.map((p) => ({
						id: p.product_id,
						name: p.product?.name || `Product ${p.product_id}`,
						amount: p.amount_aggregated || p.amount,
						best_before_date: p.best_before_date,
					}));

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									summary: {
										due_soon: data.due_products.length,
										overdue: data.overdue_products.length,
										expired: data.expired_products.length,
										missing: data.missing_products.length,
									},
									due_products: formatProducts(data.due_products),
									overdue_products: formatProducts(data.overdue_products),
									expired_products: formatProducts(data.expired_products),
									missing_products: data.missing_products.map((p) => ({
										id: p.id,
										name: p.name,
										amount_missing: p.amount_missing,
										is_partly_in_stock: p.is_partly_in_stock,
									})),
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error fetching volatile stock: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// STOCK - GET PRODUCT BY BARCODE
	server.registerTool(
		"grocy_stock_get_product_by_barcode",
		{
			title: "Get Product by Barcode",
			description:
				"Look up a product using its barcode. Returns product details if the barcode is registered.",
			inputSchema: {
				barcode: z.string().min(1).describe("The barcode to look up"),
			},
			outputSchema: {
				product: z.object({
					id: z.number(),
					name: z.string(),
					barcode: z.string(),
				}),
			},
		},
		async ({ barcode }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const data = (await grocyRequest(
					`stock/products/by-barcode/${encodeURIComponent(barcode)}`
				)) as GrocyProductDetails;

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									id: data.product.id,
									name: data.product.name,
									barcode: barcode,
									stock_amount: data.stock_amount,
									location: data.location?.name,
									last_price: data.last_price,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error looking up barcode: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// SHOPPING LIST - ADD PRODUCT
	server.registerTool(
		"grocy_shoppinglist_add_product",
		{
			title: "Add Product to Shopping List",
			description:
				"Adds a product to your shopping list. If the product is already on the list, " +
				"the amount will be increased.",
			inputSchema: {
				product_id: z.number().positive().describe("Product ID to add"),
				product_amount: z
					.number()
					.optional()
					.default(1)
					.describe("Amount to add (default: 1)"),
				list_id: z
					.number()
					.optional()
					.default(1)
					.describe("Shopping list ID (default: 1 = default list)"),
				note: z.string().optional().describe("Optional note for the item"),
			},
			outputSchema: {
				success: z.boolean(),
				message: z.string(),
			},
		},
		async ({ product_id, product_amount = 1, list_id = 1, note }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const body: Record<string, unknown> = {
					product_id,
					product_amount,
					list_id,
				};

				if (note) body.note = note;

				await grocyRequest("stock/shoppinglist/add-product", "POST", body);

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Added ${product_amount} unit(s) of product ${product_id} to shopping list ${list_id}`,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error adding to shopping list: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// SHOPPING LIST - REMOVE PRODUCT
	server.registerTool(
		"grocy_shoppinglist_remove_product",
		{
			title: "Remove Product from Shopping List",
			description:
				"Removes a product from your shopping list. If the amount is less than what's on the list, " +
				"it reduces the amount. Otherwise, removes the item completely.",
			inputSchema: {
				product_id: z.number().positive().describe("Product ID to remove"),
				product_amount: z
					.number()
					.optional()
					.default(1)
					.describe("Amount to remove (default: 1)"),
				list_id: z
					.number()
					.optional()
					.default(1)
					.describe("Shopping list ID (default: 1 = default list)"),
			},
			outputSchema: {
				success: z.boolean(),
				message: z.string(),
			},
		},
		async ({ product_id, product_amount = 1, list_id = 1 }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const body = {
					product_id,
					product_amount,
					list_id,
				};

				await grocyRequest("stock/shoppinglist/remove-product", "POST", body);

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Removed ${product_amount} unit(s) of product ${product_id} from shopping list ${list_id}`,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error removing from shopping list: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// SHOPPING LIST - ADD MISSING PRODUCTS
	server.registerTool(
		"grocy_shoppinglist_add_missing",
		{
			title: "Add Missing Products to Shopping List",
			description:
				"Automatically adds all products below their minimum stock amount to the shopping list. " +
				"Great for restocking your pantry.",
			inputSchema: {
				list_id: z
					.number()
					.optional()
					.default(1)
					.describe("Shopping list ID (default: 1 = default list)"),
			},
			outputSchema: {
				success: z.boolean(),
				message: z.string(),
			},
		},
		async ({ list_id = 1 }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				await grocyRequest("stock/shoppinglist/add-missing-products", "POST", {
					list_id,
				});

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Added all missing products (below min stock) to shopping list ${list_id}`,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error adding missing products: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// SHOPPING LIST - CLEAR
	server.registerTool(
		"grocy_shoppinglist_clear",
		{
			title: "Clear Shopping List",
			description:
				"Removes all items from a shopping list. Can optionally remove only completed items.",
			inputSchema: {
				list_id: z
					.number()
					.optional()
					.default(1)
					.describe("Shopping list ID (default: 1 = default list)"),
				done_only: z
					.boolean()
					.optional()
					.default(false)
					.describe("If true, only removes completed items (default: false)"),
			},
			outputSchema: {
				success: z.boolean(),
				message: z.string(),
			},
		},
		async ({ list_id = 1, done_only = false }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				await grocyRequest("stock/shoppinglist/clear", "POST", {
					list_id,
					done_only,
				});

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: done_only
										? `Cleared completed items from shopping list ${list_id}`
										: `Cleared all items from shopping list ${list_id}`,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error clearing shopping list: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// RECIPES - GET FULFILLMENT
	server.registerTool(
		"grocy_recipe_get_fulfillment",
		{
			title: "Check Recipe Fulfillment",
			description:
				"Checks if you have all ingredients in stock for a recipe. " +
				"Shows which ingredients are missing.",
			inputSchema: {
				recipe_id: z.number().positive().describe("Recipe ID to check"),
			},
			outputSchema: {
				fulfillment: z.object({
					need_fulfilled: z.boolean(),
					missing_products: z.array(
						z.object({
							id: z.number(),
							amount_missing: z.number(),
						})
					),
				}),
			},
		},
		async ({ recipe_id }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const data = (await grocyRequest(
					`recipes/${recipe_id}/fulfillment`
				)) as GrocyRecipeFulfillment;

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									recipe_id,
									need_fulfilled: data.need_fulfilled,
									need_fulfilled_with_shopping_list:
										data.need_fulfilled_with_shopping_list,
									missing_products: data.missing_products,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error checking recipe fulfillment: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// RECIPES - CONSUME
	server.registerTool(
		"grocy_recipe_consume",
		{
			title: "Consume Recipe Ingredients",
			description:
				"Consumes all ingredients for a recipe from stock. " +
				"Only works if all ingredients are available (check fulfillment first).",
			inputSchema: {
				recipe_id: z.number().positive().describe("Recipe ID to consume"),
			},
			outputSchema: {
				success: z.boolean(),
				message: z.string(),
			},
		},
		async ({ recipe_id }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				await grocyRequest(`recipes/${recipe_id}/consume`, "POST");

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Successfully consumed all ingredients for recipe ${recipe_id}`,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error consuming recipe: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// RECIPES - ADD MISSING TO SHOPPING LIST
	server.registerTool(
		"grocy_recipe_add_missing_to_shoppinglist",
		{
			title: "Add Missing Recipe Ingredients to Shopping List",
			description:
				"Adds all missing ingredients for a recipe to your shopping list. " +
				"Useful for meal planning.",
			inputSchema: {
				recipe_id: z.number().positive().describe("Recipe ID"),
				excluded_product_ids: z
					.array(z.number())
					.optional()
					.describe("Product IDs to exclude from shopping list"),
			},
			outputSchema: {
				success: z.boolean(),
				message: z.string(),
			},
		},
		async ({ recipe_id, excluded_product_ids }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const body = excluded_product_ids
					? { excludedProductIds: excluded_product_ids }
					: undefined;

				await grocyRequest(
					`recipes/${recipe_id}/add-not-fulfilled-products-to-shoppinglist`,
					"POST",
					body
				);

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Added missing ingredients for recipe ${recipe_id} to shopping list`,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error adding recipe ingredients to shopping list: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// TASKS - GET PENDING
	server.registerTool(
		"grocy_tasks_get_pending",
		{
			title: "Get Pending Tasks",
			description:
				"Returns all tasks that are not yet completed. Shows task names, due dates, and assignments.",
			inputSchema: {},
			outputSchema: {
				tasks: z.array(
					z.object({
						id: z.number(),
						name: z.string(),
						due_date: z.string().optional(),
						description: z.string().optional(),
					})
				),
			},
		},
		async () => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const data = (await grocyRequest("tasks")) as Array<{
					id: number;
					name: string;
					description?: string;
					due_date?: string;
					done: number;
					assigned_to_user_id?: number;
				}>;

				const pendingTasks = data.filter((task) => task.done === 0);

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									total_pending: pendingTasks.length,
									tasks: pendingTasks.map((task) => ({
										id: task.id,
										name: task.name,
										description: task.description,
										due_date: task.due_date,
										assigned_to_user_id: task.assigned_to_user_id,
									})),
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error fetching tasks: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// TASKS - COMPLETE
	server.registerTool(
		"grocy_task_complete",
		{
			title: "Complete Task",
			description: "Marks a task as completed with the current timestamp.",
			inputSchema: {
				task_id: z.number().positive().describe("Task ID to complete"),
			},
			outputSchema: {
				success: z.boolean(),
				message: z.string(),
			},
		},
		async ({ task_id }) => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				await grocyRequest(`tasks/${task_id}/complete`, "POST", {});

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									success: true,
									message: `Task ${task_id} marked as completed`,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error completing task: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);

	// SYSTEM - GET INFO
	server.registerTool(
		"grocy_system_info",
		{
			title: "Get Grocy System Info",
			description:
				"Returns information about your Grocy installation including version, PHP version, and database info.",
			inputSchema: {},
			outputSchema: {
				info: z.object({
					grocy_version: z.string(),
					php_version: z.string(),
					sqlite_version: z.string(),
				}),
			},
		},
		async () => {
			try {
				if (!genericLimiter.allowCall()) {
					const waitTime = Math.ceil(genericLimiter.getWaitTime() / 1000);
					return {
						content: [
							{
								type: "text",
								text: `Rate limit exceeded. Please wait ${waitTime} seconds.`,
							},
						],
						isError: true,
					};
				}

				const data = (await grocyRequest("system/info")) as {
					grocy_version: { Version: string; ReleaseDate: string };
					php_version: string;
					sqlite_version: string;
				};

				return {
					content: [
						{
							type: "text",
							text: JSON.stringify(
								{
									grocy_version: data.grocy_version.Version,
									release_date: data.grocy_version.ReleaseDate,
									php_version: data.php_version,
									sqlite_version: data.sqlite_version,
								},
								null,
								2
							),
						},
					],
				};
			} catch (error) {
				return {
					content: [
						{
							type: "text",
							text: `Error fetching system info: ${
								error instanceof Error ? error.message : String(error)
							}`,
						},
					],
					isError: true,
				};
			}
		}
	);
}
